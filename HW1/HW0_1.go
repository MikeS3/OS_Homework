//process/pipe implementation in Go generated by ChatGPT
package main

// import fmt for printing and scanning; os for os-level features like meaking pipes; sync for sync primitives; time for creating delays
import (
    "fmt"
    "os"
    "sync"
    "time"
)

func producer(pipeWriter *os.File, wg *sync.WaitGroup) {
    defer wg.Done() // when the function exits the goroutine is marked as done
    for i := 1; i <= 5; i++ {
        fmt.Fprintln(pipeWriter, i) // Write number to pipe
        fmt.Println("Producer:", i) // print number to the screen
        time.Sleep(500 * time.Millisecond) // 500 ms Delay
    }
    pipeWriter.Close() // Close pipe after writing
}

func consumer(pipeReader *os.File, wg *sync.WaitGroup) {
    defer wg.Done() // when the function exits mark the goroutine as done
    var num int
    for {
        _, err := fmt.Fscanf(pipeReader, "%d\n", &num) // read an integer from the pipe into the variable num
        if err != nil {
            break // Exit when there is an error reading from the pipe
        }
        fmt.Println("Consumer:", num) // print the number to the screen
    }
}

func main() {
    r, w, err := os.Pipe() // Create a pipe for inter process communication
    if err != nil {
        fmt.Println("Error creating pipe:", err) // print an error if there is an error when making the IPC pipe
        return
    }

    var wg sync.WaitGroup // create a wait group
    wg.Add(2) // increase waitgroup by 2 for the proucer and consumer goroutines


    go producer(w, &wg) // start the producer goroutine
    go consumer(r, &wg) // start the consumer goroutine

    wg.Wait() // Wait for both goroutines to finish
}

